# DeepAgentUI æ¶æ„é‡æ„è¿ç§»æ–¹æ¡ˆ

## ä¸€ã€æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£é’ˆå¯¹ DeepAgentUI é¡¹ç›®å‚è€ƒ OpenWork æ¶æ„ï¼Œå¯¹ Session ç®¡ç†ã€Workspace ç®¡ç†ã€æŒä¹…åŒ–å±‚å’Œ HITLï¼ˆHuman-in-the-Loopï¼‰æœºåˆ¶è¿›è¡Œé‡æ„ï¼Œè®¾è®¡åŸºäºæ–‡ä»¶ç³»ç»Ÿçš„æŒä¹…åŒ–æ–¹æ¡ˆï¼ˆä¸ä½¿ç”¨ SQLï¼‰ï¼Œå¹¶æä¾›å®Œæ•´çš„è¿ç§»è·¯å¾„ã€‚

## äºŒã€å½“å‰æ¶æ„åˆ†æ

### 2.1 ç°æœ‰æ¶æ„ç»„ä»¶

#### Session ç®¡ç†ï¼ˆå½“å‰å®ç°ï¼‰
- **ä½ç½®**ï¼š`backend/agent/session-routes.ts` + `electron/ipc/session.ts`
- **å­˜å‚¨ç»“æ„**ï¼š
  ```
  workspaces/
    {sessionId}/
      meta/
        session.json      # ä¼šè¯å…ƒæ•°æ®
        messages.json     # å†å²æ¶ˆæ¯ï¼ˆåˆ†ç¦»å­˜å‚¨ï¼‰
        todos.json        # Todoåˆ—è¡¨ï¼ˆåˆ†ç¦»å­˜å‚¨ï¼‰
      images/            # å›¾ç‰‡èµ„æº
      audio/             # éŸ³é¢‘èµ„æº
      llm_logs/          # LLMè°ƒç”¨æ—¥å¿—
  ```
- **æ ¸å¿ƒåŠŸèƒ½**ï¼š
  - ä¼šè¯åˆ›å»º/åˆ—è¡¨/è¯¦æƒ…/æ›´æ–°/åˆ é™¤
  - æ¶ˆæ¯å’ŒTodosç‹¬ç«‹æ–‡ä»¶å­˜å‚¨
  - æ–‡ä»¶èµ„æºæŒ‰ç±»å‹åˆ†ç±»

#### Workspace ç®¡ç†ï¼ˆå½“å‰å®ç°ï¼‰
- **ä½ç½®**ï¼š`backend/services/fs.ts`
- **æ ¸å¿ƒç±»**ï¼š`WorkspaceFilesystem`
- **åŠŸèƒ½**ï¼š
  - Sessionéš”ç¦»çš„æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
  - è·¯å¾„å®‰å…¨æ£€æŸ¥ï¼ˆé˜²æ­¢è¶Šç•Œï¼‰
  - æ–‡ä»¶è¯»å†™ã€lsã€globã€grep ç­‰æ“ä½œ
  - æ–‡ä»¶URIè½¬æ¢ï¼ˆfile:// åè®®ï¼‰

#### æŒä¹…åŒ–å±‚ï¼ˆå½“å‰å®ç°ï¼‰
- **æ–¹å¼**ï¼šæ–‡ä»¶ç³»ç»Ÿï¼ˆJSONï¼‰
- **ä½ç½®**ï¼š`outputs/workspaces/{sessionId}/`
- **ä¼˜ç‚¹**ï¼šç®€å•ã€é€æ˜ã€ä¾¿äºè°ƒè¯•
- **ç¼ºç‚¹**ï¼šç¼ºä¹ Agent çŠ¶æ€æŒä¹…åŒ–ï¼ˆOpenWork çš„ checkpoint æœºåˆ¶ï¼‰

#### HITL æœºåˆ¶ï¼ˆå½“å‰å®ç°ï¼‰
- **ä½ç½®**ï¼š`backend/agent/AgentFactory.ts` - `requestHumanConfirm()`
- **è§¦å‘åœºæ™¯**ï¼št2iï¼ˆæ–‡ç”Ÿå›¾ï¼‰ã€ttsï¼ˆæ–‡å­—è½¬è¯­éŸ³ï¼‰
- **å®ç°æ–¹å¼**ï¼š
  - Electron IPC é€šä¿¡
  - 30ç§’è¶…æ—¶æœºåˆ¶
  - å‰ç«¯å¼¹çª—ç¡®è®¤

### 2.2 æ¶æ„é—®é¢˜ä¸æ”¹è¿›ç‚¹

| é—®é¢˜ç±»å‹ | å½“å‰çŠ¶æ€ | æ”¹è¿›ç›®æ ‡ |
|---------|---------|---------|
| Agent çŠ¶æ€æŒä¹…åŒ– | âŒ æ— çŠ¶æ€æŒä¹…åŒ– | âœ… å®ç°åŸºäºæ–‡ä»¶çš„ checkpoint æœºåˆ¶ |
| HITL è¦†ç›–èŒƒå›´ | âš ï¸ ä»…è¦†ç›– t2i/tts | âœ… æ‰©å±•åˆ°æ–‡ä»¶å†™å…¥ã€shellæ‰§è¡Œç­‰é«˜é£é™©æ“ä½œ |
| Session ç”Ÿå‘½å‘¨æœŸ | âš ï¸ æ— è‡ªåŠ¨æ¸…ç† | âœ… æ·»åŠ è¿‡æœŸæ¸…ç†ç­–ç•¥ |
| Workspace éš”ç¦» | âœ… è·¯å¾„éš”ç¦»å®Œå–„ | ğŸ”§ å¢å¼ºæƒé™æ§åˆ¶å’Œèµ„æºç›‘æ§ |
| æ“ä½œå®¡è®¡ | âŒ æ— å®¡è®¡æ—¥å¿— | âœ… æ·»åŠ æ“ä½œæ—¥å¿—å’Œå®¡è®¡è¿½è¸ª |

---

## ä¸‰ã€é‡æ„æ¶æ„è®¾è®¡

### 3.1 æ•´ä½“æ¶æ„åˆ†å±‚

å‚è€ƒ OpenWork æ¶æ„ï¼Œè®¾è®¡äº”å±‚æ¶æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åº”ç”¨å±‚ (UI)                            â”‚
â”‚         ChatProvider + SessionManager + Components          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     IPC é€šä¿¡å±‚ (Electron)                      â”‚
â”‚         session.ts + agent.ts + fs.ts + hitl.ts            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ä¸šåŠ¡é€»è¾‘å±‚ (Backend)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Session ç®¡ç†  â”‚ Workspace ç®¡ç†â”‚  HITL ç®¡ç†   â”‚ Agent è¿è¡Œæ—¶â”‚ â”‚
â”‚  â”‚ SessionServiceâ”‚WorkspaceServiceâ”‚  HITLServiceâ”‚ Runtime   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æŒä¹…åŒ–å±‚ (Persistence)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚           FileBasedPersistence (JSON)                  â”‚ â”‚
â”‚  â”‚  - Checkpoint å­˜å‚¨    - Session å…ƒæ•°æ®                  â”‚ â”‚
â”‚  â”‚  - æ¶ˆæ¯å†å²          - æ“ä½œå®¡è®¡æ—¥å¿—                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ–‡ä»¶ç³»ç»Ÿå±‚ (Storage)                       â”‚
â”‚            outputs/workspaces/{sessionId}/                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ ¸å¿ƒæ¨¡å—é‡æ„è®¾è®¡

#### 3.2.1 Session ç®¡ç†å¢å¼º

**æ–°å¢åŠŸèƒ½**ï¼š
1. **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šè‡ªåŠ¨è¿‡æœŸæ¸…ç†ã€å½’æ¡£
2. **çŠ¶æ€è·Ÿè¸ª**ï¼šactive/paused/archived/deleted
3. **èµ„æºç»Ÿè®¡**ï¼šæ–‡ä»¶æ•°é‡ã€å¤§å°ã€LLM token æ¶ˆè€—

**æ•°æ®ç»“æ„ï¼ˆsession.jsonï¼‰**ï¼š
```typescript
interface SessionMeta {
  // åŸºç¡€ä¿¡æ¯
  sessionId: string;
  title: string;
  createdAt: string;
  updatedAt: string;
  lastAccessedAt: string;
  
  // çŠ¶æ€ç®¡ç†
  status: 'active' | 'paused' | 'archived' | 'deleted';
  
  // å…³è”æ•°æ®
  threadIds: string[];  // å…³è”çš„å¯¹è¯çº¿ç¨‹
  workspaceId: string;  // å·¥ä½œåŒºIDï¼ˆsessionIdä½œä¸ºé»˜è®¤ï¼‰
  
  // å…ƒæ•°æ®
  prompt?: string;
  tags?: string[];
  
  // èµ„æºç»Ÿè®¡
  stats: {
    messageCount: number;
    fileCount: number;
    totalSize: number;  // bytes
    llmTokens: number;
  };
  
  // ç”Ÿå‘½å‘¨æœŸ
  expiresAt?: string;  // è¿‡æœŸæ—¶é—´
  archiveConfig?: {
    autoArchiveDays: number;
    deleteAfterArchiveDays: number;
  };
}
```

**æ ¸å¿ƒç±»è®¾è®¡**ï¼š
```typescript
// backend/services/session-service.ts

export class SessionService {
  constructor(
    private workspaceService: WorkspaceFilesystem,
    private persistenceService: PersistenceService
  ) {}

  // ä¼šè¯ç”Ÿå‘½å‘¨æœŸ
  async create(options: CreateSessionOptions): Promise<SessionMeta>
  async get(sessionId: string): Promise<SessionWithData>
  async update(sessionId: string, updates: Partial<SessionMeta>): Promise<SessionMeta>
  async delete(sessionId: string, options?: DeleteOptions): Promise<void>
  async archive(sessionId: string): Promise<void>
  
  // ä¼šè¯åˆ—è¡¨ä¸æŸ¥è¯¢
  async list(filter?: SessionFilter): Promise<SessionMeta[]>
  async search(query: string): Promise<SessionMeta[]>
  
  // ç”Ÿå‘½å‘¨æœŸç®¡ç†
  async cleanupExpired(): Promise<string[]>  // è¿”å›æ¸…ç†çš„sessionIdåˆ—è¡¨
  async updateLastAccess(sessionId: string): Promise<void>
  
  // èµ„æºç»Ÿè®¡
  async updateStats(sessionId: string): Promise<SessionStats>
  async getStats(sessionId: string): Promise<SessionStats>
}
```

#### 3.2.2 Workspace ç®¡ç†å¢å¼º

**æ–°å¢åŠŸèƒ½**ï¼š
1. **èµ„æºé…é¢**ï¼šæ–‡ä»¶æ•°é‡ã€å¤§å°é™åˆ¶
2. **æ“ä½œç›‘æ§**ï¼šå®æ—¶è·Ÿè¸ªæ–‡ä»¶æ“ä½œ
3. **æƒé™æ§åˆ¶**ï¼šè¯»å†™æƒé™åˆ†ç¦»

**æ ¸å¿ƒå¢å¼º**ï¼š
```typescript
// backend/services/workspace-service.ts

export interface WorkspaceConfig {
  rootDir: string;
  sessionId: string;
  
  // èµ„æºé™åˆ¶
  quotas: {
    maxFiles: number;         // é»˜è®¤: 1000
    maxFileSize: number;      // é»˜è®¤: 50MB
    maxTotalSize: number;     // é»˜è®¤: 500MB
  };
  
  // æƒé™æ§åˆ¶
  permissions: {
    canRead: boolean;
    canWrite: boolean;
    canExecute: boolean;
    allowedExtensions?: string[];  // ç™½åå•æ–‡ä»¶æ‰©å±•å
    blockedExtensions?: string[];  // é»‘åå•æ–‡ä»¶æ‰©å±•å
  };
  
  // ç›‘æ§é…ç½®
  monitoring: {
    enabled: boolean;
    logOperations: boolean;
  };
}

export class WorkspaceService extends WorkspaceFilesystem {
  private config: WorkspaceConfig;
  private monitor: WorkspaceMonitor;
  
  // èµ„æºæ£€æŸ¥
  async checkQuota(sessionId: string): Promise<QuotaStatus>
  async enforceQuota(sessionId: string): Promise<void>
  
  // æƒé™æ£€æŸ¥
  checkPermission(operation: 'read' | 'write' | 'execute', filePath: string): boolean
  checkFileExtension(filePath: string): boolean
  
  // æ“ä½œç›‘æ§ï¼ˆé›†æˆå®¡è®¡ï¼‰
  async logOperation(op: FileOperation): Promise<void>
  
  // é‡å†™æ ¸å¿ƒæ–¹æ³•æ·»åŠ æ£€æŸ¥
  async writeFile(sessionId: string, relativePath: string, data: any): Promise<string> {
    // 1. æƒé™æ£€æŸ¥
    if (!this.checkPermission('write', relativePath)) {
      throw new Error('Write permission denied');
    }
    
    // 2. æ–‡ä»¶æ‰©å±•åæ£€æŸ¥
    if (!this.checkFileExtension(relativePath)) {
      throw new Error('File extension not allowed');
    }
    
    // 3. é…é¢æ£€æŸ¥
    await this.enforceQuota(sessionId);
    
    // 4. æ‰§è¡Œå†™å…¥
    const result = await super.writeFile(sessionId, relativePath, data);
    
    // 5. è®°å½•æ“ä½œ
    await this.logOperation({
      type: 'write',
      sessionId,
      path: relativePath,
      timestamp: new Date().toISOString()
    });
    
    return result;
  }
}
```

#### 3.2.3 æŒä¹…åŒ–å±‚ï¼ˆåŸºäºæ–‡ä»¶çš„ Checkpointï¼‰

**è®¾è®¡ç›®æ ‡**ï¼šæ›¿ä»£ OpenWork çš„ SqlJsSaverï¼Œä½¿ç”¨ JSON æ–‡ä»¶å®ç° checkpoint æœºåˆ¶

**é‡è¦ç®€åŒ–**ï¼šç”±äºé¡¹ç›®å•çº¿ç¨‹è¿è¡Œï¼Œcheckpoint åªéœ€è¦ sessionIdï¼Œæ— éœ€ threadId

**Checkpoint ç»“æ„**ï¼š
```
workspaces/{sessionId}/
  checkpoints/
    metadata.json       # checkpoint å…ƒæ•°æ®
    state_001.json      # çŠ¶æ€å¿«ç…§ #1
    state_002.json      # çŠ¶æ€å¿«ç…§ #2
    state_latest.json   # æœ€æ–°çŠ¶æ€ï¼ˆè½¯é“¾æ¥æˆ–æ‹·è´ï¼‰
    index.json          # checkpoint ç´¢å¼•
```

**æ ¸å¿ƒæ¥å£**ï¼š
```typescript
// backend/services/persistence-service.ts

export interface CheckpointState {
  checkpointId: string;
  sessionId: string;
  timestamp: string;
  messages: any[];
  todos: any[];
  context: Record<string, any>;
  executionStep: number;
  metadata: {
    totalTokens: number;
    model: string;
    recursionDepth: number;
  };
}

export class FileBasedCheckpointer {
  constructor(sessionId: string, workspaceService: WorkspaceFilesystem)
  
  // Checkpoint ç®¡ç†ï¼ˆå…³é”®æ–¹æ³•ï¼‰
  async save(state: Partial<CheckpointState>): Promise<string>
  async load(checkpointId?: string): Promise<CheckpointState | null>
  async list(): Promise<CheckpointMetadata[]>
  async cleanup(options?: CleanupOptions): Promise<void>
}

export class PersistenceService {
  // è·å–æˆ–åˆ›å»º checkpointerï¼ˆç®€åŒ–ä¸ºåªéœ€ sessionIdï¼‰
  getCheckpointer(sessionId: string): FileBasedCheckpointer
  
  // å…³é—­ç®¡ç†
  async closeCheckpointer(sessionId: string): Promise<void>
  async closeAllCheckpointers(): Promise<void>
  
  // æ¶ˆæ¯/Todos æŒä¹…åŒ–
  async saveMessages(sessionId: string, messages: any[]): Promise<void>
  async loadMessages(sessionId: string): Promise<any[]>
  async saveTodos(sessionId: string, todos: any[]): Promise<void>
  async loadTodos(sessionId: string): Promise<any[]>
}
```

#### 3.2.4 HITL ç®¡ç†å¢å¼º

**æ‰©å±•è§¦å‘åœºæ™¯**ï¼š
1. âœ… æ–‡ç”Ÿå›¾ï¼ˆt2iï¼‰- å·²æœ‰
2. âœ… è¯­éŸ³åˆæˆï¼ˆttsï¼‰- å·²æœ‰
3. ğŸ†• æ–‡ä»¶å†™å…¥ï¼ˆwrite_fileï¼‰- æ–°å¢
4. ğŸ†• æ–‡ä»¶åˆ é™¤ï¼ˆrmï¼‰- æ–°å¢
5. ğŸ†• Shell æ‰§è¡Œï¼ˆexecuteï¼‰- æ–°å¢
6. ğŸ†• ç½‘ç»œè¯·æ±‚ï¼ˆfetchï¼‰- æ–°å¢

**HITL å†³ç­–é…ç½®**ï¼š
```typescript
// backend/config/hitl-config.ts

export interface HITLRule {
  action: string;  // æ“ä½œç±»å‹ï¼š't2i' | 'tts' | 'write_file' | 'rm' | 'execute' | 'fetch'
  enabled: boolean;
  autoApprove?: {
    enabled: boolean;
    conditions?: HITLCondition[];  // è‡ªåŠ¨æ‰¹å‡†æ¡ä»¶
  };
  timeout: number;  // è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  requireReason?: boolean;  // æ˜¯å¦éœ€è¦ç”¨æˆ·å¡«å†™ç†ç”±
}

export interface HITLCondition {
  type: 'whitelist' | 'filesize' | 'extension' | 'command';
  value: any;
}

export const DEFAULT_HITL_CONFIG: Record<string, HITLRule> = {
  t2i: {
    action: 't2i',
    enabled: true,
    timeout: 30000,
  },
  tts: {
    action: 'tts',
    enabled: true,
    timeout: 30000,
  },
  write_file: {
    action: 'write_file',
    enabled: true,
    autoApprove: {
      enabled: true,
      conditions: [
        { type: 'extension', value: ['.txt', '.json', '.md'] },
        { type: 'filesize', value: { max: 1024 * 1024 } }  // 1MB
      ]
    },
    timeout: 60000,
  },
  rm: {
    action: 'rm',
    enabled: true,
    timeout: 60000,
    requireReason: true,
  },
  execute: {
    action: 'execute',
    enabled: true,
    autoApprove: {
      enabled: true,
      conditions: [
        { type: 'whitelist', value: ['ls', 'pwd', 'echo', 'cat'] }
      ]
    },
    timeout: 60000,
  }
};
```

**æ ¸å¿ƒæœåŠ¡è®¾è®¡**ï¼š
```typescript
// backend/services/hitl-service.ts

export interface HITLRequest {
  requestId: string;
  action: string;
  payload: any;
  sessionId: string;
  threadId: string;
  timestamp: string;
  status: 'pending' | 'approved' | 'rejected' | 'timeout';
  reason?: string;  // ç”¨æˆ·å¡«å†™çš„ç†ç”±æˆ–æ‹’ç»åŸå› 
}

export class HITLService {
  constructor(
    private config: Record<string, HITLRule>,
    private persistenceService: PersistenceService
  ) {}
  
  // æ ¸å¿ƒè¯·æ±‚æµç¨‹
  async requestApproval(request: Omit<HITLRequest, 'requestId' | 'timestamp' | 'status'>): Promise<HITLResponse> {
    const rule = this.config[request.action];
    
    if (!rule || !rule.enabled) {
      return { approved: true, reason: 'HITL disabled for this action' };
    }
    
    // è‡ªåŠ¨æ‰¹å‡†æ£€æŸ¥
    if (rule.autoApprove?.enabled) {
      const autoApproved = await this.checkAutoApprove(request, rule.autoApprove.conditions);
      if (autoApproved) {
        await this.logApproval(request, 'auto-approved');
        return { approved: true, reason: 'auto-approved' };
      }
    }
    
    // è¯·æ±‚äººå·¥ç¡®è®¤
    const fullRequest: HITLRequest = {
      ...request,
      requestId: randomUUID(),
      timestamp: new Date().toISOString(),
      status: 'pending',
    };
    
    // ä¿å­˜è¯·æ±‚è®°å½•
    await this.saveRequest(fullRequest);
    
    // å‘é€åˆ°å‰ç«¯
    const response = await this.sendToUI(fullRequest, rule.timeout);
    
    // æ›´æ–°è¯·æ±‚çŠ¶æ€
    fullRequest.status = response.approved ? 'approved' : 'rejected';
    fullRequest.reason = response.reason;
    await this.saveRequest(fullRequest);
    
    return response;
  }
  
  // è‡ªåŠ¨æ‰¹å‡†æ¡ä»¶æ£€æŸ¥
  private async checkAutoApprove(request: HITLRequest, conditions?: HITLCondition[]): Promise<boolean> {
    if (!conditions || conditions.length === 0) return false;
    
    for (const condition of conditions) {
      switch (condition.type) {
        case 'whitelist':
          // æ£€æŸ¥å‘½ä»¤æ˜¯å¦åœ¨ç™½åå•
          if (!condition.value.includes(request.payload.command)) {
            return false;
          }
          break;
        case 'filesize':
          // æ£€æŸ¥æ–‡ä»¶å¤§å°
          if (request.payload.size > condition.value.max) {
            return false;
          }
          break;
        case 'extension':
          // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
          const ext = path.extname(request.payload.filename);
          if (!condition.value.includes(ext)) {
            return false;
          }
          break;
      }
    }
    
    return true;
  }
  
  // UI é€šä¿¡
  private async sendToUI(request: HITLRequest, timeout: number): Promise<HITLResponse> {
    const { BrowserWindow, ipcMain } = await import('electron');
    const win = BrowserWindow.getAllWindows()[0];
    if (!win) throw new Error('No window available');
    
    win.webContents.send('hitl:request', request);
    
    return new Promise((resolve) => {
      let settled = false;
      const timer = setTimeout(() => {
        if (!settled) {
          settled = true;
          resolve({ approved: false, reason: 'timeout' });
        }
      }, timeout);
      
      ipcMain.once(`hitl:response:${request.requestId}`, (_event, response) => {
        if (!settled) {
          settled = true;
          clearTimeout(timer);
          resolve(response);
        }
      });
    });
  }
  
  // å®¡è®¡æ—¥å¿—
  async getRequestHistory(sessionId: string): Promise<HITLRequest[]>
  async logApproval(request: HITLRequest, result: string): Promise<void>
  
  // æŒä¹…åŒ–
  private async saveRequest(request: HITLRequest): Promise<void>
}
```

#### 3.2.5 æ“ä½œå®¡è®¡æ—¥å¿—

**æ—¥å¿—ç»“æ„**ï¼š
```typescript
// backend/services/audit-service.ts

export interface AuditLog {
  logId: string;
  sessionId: string;
  threadId?: string;
  timestamp: string;
  
  // æ“ä½œä¿¡æ¯
  operation: {
    type: 'file' | 'hitl' | 'agent' | 'session';
    action: string;  // 'read', 'write', 'delete', 'execute', 'approve', 'reject'
    resource: string;  // èµ„æºè·¯å¾„æˆ–æ ‡è¯†
    metadata?: Record<string, any>;
  };
  
  // ç»“æœä¿¡æ¯
  result: {
    success: boolean;
    error?: string;
    duration?: number;  // æ¯«ç§’
  };
  
  // ç”¨æˆ·ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
  user?: {
    id: string;
    action: 'manual' | 'auto';
  };
}

export class AuditService {
  constructor(private workspaceService: WorkspaceFilesystem) {}
  
  // è®°å½•æ—¥å¿—
  async log(entry: Omit<AuditLog, 'logId' | 'timestamp'>): Promise<void> {
    const log: AuditLog = {
      ...entry,
      logId: randomUUID(),
      timestamp: new Date().toISOString(),
    };
    
    // å†™å…¥åˆ° session çš„å®¡è®¡æ—¥å¿—æ–‡ä»¶
    const logPath = `meta/audit/${new Date().toISOString().split('T')[0]}.jsonl`;
    const logLine = JSON.stringify(log) + '\n';
    
    await this.workspaceService.appendFile(
      entry.sessionId,
      logPath,
      logLine,
      'utf-8'
    );
  }
  
  // æŸ¥è¯¢æ—¥å¿—
  async query(sessionId: string, filter?: AuditFilter): Promise<AuditLog[]>
  async export(sessionId: string, format: 'json' | 'csv'): Promise<string>
}
```

### 3.3 æ ¸å¿ƒå…¥å£ï¼šcreateAgentRuntime

**è®¾è®¡ç›®æ ‡**ï¼šç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ¨¡å—çš„åˆ›å»ºå’Œå…³è”ï¼Œç®€åŒ– Agent åˆå§‹åŒ–æµç¨‹

**æ ¸å¿ƒå‡½æ•°**ï¼š
```typescript
// backend/services/runtime-manager.ts

export interface AgentRuntimeOptions {
  sessionId: string;
  config?: AgentConfig;
}

export interface AgentRuntime {
  sessionId: string;
  agent: any;  // DeepAgent instance
  checkpointer: FileBasedCheckpointer;
  workspace: WorkspaceService;
  hitl: HITLService;
  audit: AuditService;
  
  // æ¸…ç†èµ„æº
  close(): Promise<void>;
}

export async function createAgentRuntime(options: AgentRuntimeOptions): Promise<AgentRuntime>
```

**è°ƒç”¨æµç¨‹**ï¼š
```
createAgentRuntime(sessionId)
  â”œâ”€â†’ 1. åˆå§‹åŒ– WorkspaceService
  â”œâ”€â†’ 2. åˆå§‹åŒ– PersistenceService
  â”‚   â””â”€â†’ getCheckpointer(sessionId)
  â”œâ”€â†’ 3. åˆå§‹åŒ– HITLService
  â”œâ”€â†’ 4. åˆå§‹åŒ– AuditService
  â”œâ”€â†’ 5. åŠ è½½ Checkpoint æ¢å¤çŠ¶æ€
  â”œâ”€â†’ 6. åˆ›å»º Agentï¼ˆæ³¨å…¥æ‰€æœ‰æœåŠ¡ï¼‰
  â””â”€â†’ è¿”å› AgentRuntime å®ä¾‹
```

### 3.4 ç»Ÿä¸€æ—¥å¿—ç®¡ç†

**æ—¥å¿—å­˜å‚¨ç­–ç•¥å˜æ›´**ï¼š

**ç°çŠ¶**ï¼š

export class LogManager {
  // LLM è°ƒç”¨æ—¥å¿—
  logLLMCall(sessionId: string, data: LLMCallData): Promise<void>
  
  // å®¡è®¡æ—¥å¿—
  logAudit(sessionId: string, entry: AuditLog): Promise<void>
  
  // HITL æ—¥å¿—
  logHITL(sessionId: string, request: HITLRequest): Promise<void>
  
  // ç³»ç»Ÿæ—¥å¿—
  logSystem(level: 'info' | 'warn' | 'error', message: string): Promise<void>
  
  // æŸ¥è¯¢ä¸å¯¼å‡º
  queryLogs(sessionId: string, type: LogType, filter?: LogFilter): Promise<any[]>
  exportLogs(sessionId: string, type: LogType, format: 'json' | 'csv'): Promise<string>
}
```

#### 3.3.3 HITL å®¡æ‰¹æµç¨‹
```
Tool Call (e.g., write_file)
    â†“
HITLService.requestApproval()
    â”œâ”€â†’ Check HITLRule
    â”‚   â”œâ”€â†’ Disabled? â†’ Auto Approve
    â”‚   â””â”€â†’ Enabled â†’ Continue
    â”œâ”€â†’ Check AutoApprove Conditions
    â”‚   â”œâ”€â†’ Match? â†’ Auto Approve â†’ AuditLog
    â”‚   â””â”€â†’ No Match â†’ Continue
    â”œâ”€â†’ Save HITLRequest to disk
    â”œâ”€â†’ Send to UI (hitl:request)
    â”œâ”€â†’ Wait for Response (with timeout)
    â”‚   â”œâ”€â†’ User Approves â†’ Execute
    â”‚   â”œâ”€â†’ User Rejects â†’ Cancel
    â”‚   â””â”€â†’ Timeout â†’ Cancel
    â””â”€â†’ Update HITLRequest Status
    â†“
AuditService.log(decision)
    â†“
Return Result to Agent
```

---

## å››ã€è¿ç§»å®æ–½æ–¹æ¡ˆ

### 4.1 è¿ç§»é˜¶æ®µåˆ’åˆ†

#### é˜¶æ®µ 1ï¼šæŒä¹…åŒ–å±‚é‡æ„ï¼ˆ1-2å‘¨ï¼‰
**ç›®æ ‡**ï¼šå®ç°åŸºäºæ–‡ä»¶çš„ Checkpoint æœºåˆ¶

**ä»»åŠ¡æ¸…å•**ï¼š
- [ ] åˆ›å»º `backend/services/persistence-service.ts`
- [ ] å®ç° `FileBasedCheckpointer` ç±»
- [ ] å®ç° `PersistenceService` ç±»
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] é›†æˆåˆ° `AgentFactory` ä¸­æ›¿ä»£å½“å‰æ— çŠ¶æ€æ–¹å¼

**æ–‡ä»¶å˜æ›´**ï¼š
```
æ–°å¢:
  backend/services/persistence-service.ts
  backend/tests/persistence-service.test.ts
ä¿®æ”¹:
  backend/agent/AgentFactory.ts
  backend/agent/factory.ts
```

**æ•°æ®è¿ç§»*æ–‡ä»¶æ¸…å•

### 4.1 æ–°å¢æ–‡ä»¶

#### æ ¸å¿ƒæœåŠ¡å±‚
```
backend/services/
  â”œâ”€â”€ persistence-service.ts      # Checkpoint æŒä¹…åŒ–æœåŠ¡
  â”œâ”€â”€ session-service.ts          # Session ç”Ÿå‘½å‘¨æœŸç®¡ç†
  â”œâ”€â”€ hitl-service.ts             # HITL å®¡æ‰¹æœåŠ¡
  â”œâ”€â”€ audit-service.ts            # å®¡è®¡æ—¥å¿—æœåŠ¡
  â”œâ”€â”€ log-manager.ts              # ç»Ÿä¸€æ—¥å¿—ç®¡ç†
  â””â”€â”€ runtime-manager.ts          # Agent è¿è¡Œæ—¶ç®¡ç†å™¨ï¼ˆcreateAgentRuntimeï¼‰
```

#### é…ç½®æ–‡ä»¶
```
backend/config/
  â”œâ”€â”€ hitl-config.ts              # HITL è§„åˆ™é…ç½®
  â”œâ”€â”€ workspace-config.ts         # Workspace é…é¢å’Œæƒé™é…ç½®
  â”œâ”€â”€ feature-flags.ts            # åŠŸèƒ½å¼€å…³
  â””â”€â”€ log-config.ts               # æ—¥å¿—é…ç½®
```

#### IPC å±‚
```
electron/ipc/
  â”œâ”€â”€ hitl.ts                     # HITL IPC å¤„ç†ï¼ˆæ–°å¢ï¼‰
  â””â”€â”€ audit.ts                    # å®¡è®¡æ—¥å¿— IPCï¼ˆæ–°å¢ï¼‰
```

#### å‰ç«¯ç»„ä»¶
```
src/components/
  â”œâ”€â”€ HITLDialog.tsx              # HITL ç¡®è®¤å¯¹è¯æ¡†ï¼ˆå¢å¼ºï¼‰
  â””â”€â”€ AuditLogViewer.tsx          # å®¡è®¡æ—¥å¿—æŸ¥çœ‹å™¨ï¼ˆæ–°å¢ï¼‰
```

#### æµ‹è¯•æ–‡ä»¶
```
backend/tests/
  â”œâ”€â”€ persistence-service.test.ts
  â”œâ”€â”€ session-service.test.ts
  â”œâ”€â”€ hitl-service.test.ts
  â”œâ”€â”€ audit-service.test.ts
  â”œâ”€â”€ runtime-manager.test.ts
  â””â”€â”€ integration.test.ts
```

### 4.2 ä¿®æ”¹æ–‡ä»¶

#### æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
```
backend/services/
  â””â”€â”€ fs.ts                       # é‡æ„ä¸º WorkspaceServiceï¼ˆæ·»åŠ é…é¢ã€æƒé™æ§åˆ¶ï¼‰

backend/agent/
  â”œâ”€â”€ AgentFactory.ts             # ä½¿ç”¨ createAgentRuntime æ›¿ä»£å½“å‰åˆå§‹åŒ–
  â”œâ”€â”€ factory.ts                  # é›†æˆæ–°æœåŠ¡
  â”œâ”€â”€ session-routes.ts           # ä½¿ç”¨ SessionService
  â””â”€â”€ LLMCallbacks.ts             # ä½¿ç”¨ LogManager
```

#### IPC å±‚
```
electron/ipc/
  â”œâ”€â”€ agent.ts                    # é›†æˆ HITLã€ç§»é™¤ threadId
  â”œâ”€â”€ session.ts                  # ä½¿ç”¨ SessionService
  â””â”€â”€ fs.ts                       # ä½¿ç”¨ WorkspaceService
```

#### å‰ç«¯
```
electron/preload.ts               # æ·»åŠ æ–° IPC æ¥å£

src/providers/
  â””â”€â”€ ChatProvider.tsx            # ç§»é™¤ threadIdã€ä½¿ç”¨æ–° Session API
```

### 4.3 åˆ é™¤/åºŸå¼ƒæ–‡ä»¶

```
backend/utils/
  â””â”€â”€ storage.ts                  # åºŸå¼ƒï¼ˆåŠŸèƒ½åˆå¹¶åˆ° SessionServiceï¼‰

outputs/workspaces/{sessionId}/
  â””â”€â”€ llm_logs/                   # è¿ç§»åˆ°ç»Ÿä¸€æ—¥å¿—ç›®å½•
```

---

## äº”ã€å®æ–½ TodoList

### Phase 1ï¼šåŸºç¡€æ¶æ„æ­å»ºï¼ˆWeek 1-2ï¼‰

#### 1.1 åˆ›å»ºæ ¸å¿ƒæœåŠ¡ï¼ˆ3å¤©ï¼‰
- [ ] **Day 1-2**: åˆ›å»º `runtime-manager.ts`
  - [ ] å®ç° `createAgentRuntime` å‡½æ•°
  - [ ] å®ç° `AgentRuntime` ç±»
  - [ ] é›†æˆæ‰€æœ‰æœåŠ¡çš„åˆå§‹åŒ–
  - [ ] ç¼–å†™å•å…ƒæµ‹è¯•
 ä¸ƒã€é£é™©ä¸åº”å¯¹

### 7.1 æŠ€æœ¯é£é™©

| é£é™© | å½±å“ | æ¦‚ç‡ | åº”å¯¹æªæ–½ |
|------|------|------|----------|
| Checkpoint æ€§èƒ½é—®é¢˜ | ä¸­ | ä½ | 1. å®ç°å¢é‡ä¿å­˜ 2. å¼‚æ­¥å†™å…¥ 3. å‹ç¼©å­˜å‚¨ 4. æ€§èƒ½æµ‹è¯•éªŒè¯ |
| HITL è¶…æ—¶é¢‘ç¹ | ä¸­ | ä¸­ | 1. å¯é…ç½®è¶…æ—¶æ—¶é—´ 2. æ–­ç‚¹ç»­ä¼ æœºåˆ¶ 3. ç¦»çº¿æ‰¹å‡†é˜Ÿåˆ— |
| æ–‡ä»¶ç³»ç»Ÿ I/O ç“¶é¢ˆ | ä¸­ | ä½ | 1. ç¼“å­˜çƒ­ç‚¹æ•°æ® 2. æ‰¹é‡å†™å…¥ 3. å¼‚æ­¥æ“ä½œ 4. ç›‘æ§ I/O æŒ‡æ ‡ |
| æ—¥å¿—æ–‡ä»¶è¿‡å¤§ | ä½ | ä¸­ | 1. æ—¥å¿—è½®è½¬ 2. è‡ªåŠ¨å‹ç¼© 3. å®šæœŸæ¸…ç† |
| ç°æœ‰ Session å…¼å®¹æ€§ | ä½ | ä½ | å‘åå…¼å®¹è®¾è®¡ï¼Œè‡ªåŠ¨è¿ç§»ï¼Œä¿ç•™å›æ»šå¼€å…³ |
| threadId ç§»é™¤å½±å“ | é«˜ | ä½ | å…¨é¢æµ‹è¯•ï¼Œç¡®ä¿æ— é—æ¼å¼•ç”¨ |

### 7.2 å®ç°æ—¥å¿—åˆ†ç±»å­˜å‚¨ï¼ˆllm/audit/system/hitlï¼‰
  - [ ] è¿ç§»ç°æœ‰ LLM æ—¥å¿—é€»è¾‘

- [ ] **Day 5**: æ—¥å¿—é›†æˆ
  - [ ] ä¿®æ”¹ `LLMCallbacks.ts` ä½¿ç”¨ LogManager
  - [ ] åˆ›å»ºæ—¥å¿—ç›®å½•ç»“æ„
  - [ ] ç¼–å†™æ—¥å¿—æŸ¥è¯¢æ¥å£

#### 1.3 é…ç½®ç³»ç»Ÿï¼ˆ2å¤©ï¼‰
- [ ] **Day 6**: åˆ›å»ºé…ç½®æ–‡ä»¶
  - [ ] åˆ›å»º `hitl-config.ts`
  - [ ] åˆ›å»º `workspace-config.ts`
  - [ ] åˆ›å»º `feature-flags.ts`
  -å…«ã€
    if (options.keepLatest) {
      toDelete = checkpoints.slice(options.keepLatest).map(c => c.checkpointId);
    }
    
    if (options.olderThan) {
      const threshold = options.olderThan.getTime();
      toDelete = checkpoints
        .filter(c => new Date(c.timestamp).getTime() < threshold)
        .map(c => c.checkpointId);
    }
    
    // åˆ é™¤æ—§ checkpoint
    await Promise.all(toDelete.map(id => this.delete(id)));
  }
  
  private async updateIndex(metadata: CheckpointMetadata): Promise<void> {
    const checkpoints = await this.list();
    checkpoints.push(metadata);
    await this.saveIndex({ checkpoints });
  }
  
  private async saveIndex(data: { checkpoints: CheckpointMetadata[] }): Promise<void> {
    await this.workspaceService.writeFile(
      this.sessionId,
      this.indexPath,
      JSON.stringify(data, null, 2),
      'utf-8'
    );
  }
}

export class PersistenceService {
  private checkpointers = new Map<string, FileBasedCheckpointer>();
  
  constructor(private workspaceService: WorkspaceFilesystem) {}
  
  getCheckpointer(sessionId: string, threadId: string): FileBasedCheckpointer {
    const key = `${sessionId}:${threadId}`;
    if (!this.checkpointers.has(key)) {
      this.checkpointers.set(
        key,
        new FileBasedCheckpointer(this.workspaceService, sessionId, threadId)
      );
    }
    return this.checkpointers.get(key)!;
  }
  
  async closeCheckpointer(sessionId: string, threadId: string): Promise<void> {
    const key = `${sessionId}:${threadId}`;
    this.checkpointers.delete(key);
  }
  
  async closeAllCheckpointers(): Promise<void> {
    this.checkpointers.clear();
  }
  
  // æ¶ˆæ¯æŒä¹…åŒ–
  async saveMessages(sessionId: string, messages: any[]): Promise<void> {
    await this.workspaceService.writeFile(
      sessionId,
      'meta/messages.json',
      JSON.stringify(messages, null, 2),
      'utf-8'
    );
  }
  
  async loadMessages(sessionId: string): Promise<any[]> {
    try {
      const content = await this.workspaceService.readFile(
        sessionId,
        'meta/messages.json',
        'utf-8'
      );
      return JSON.parse(content as string);
    } catch {
      return [];
    }
  }
  
  // Todos æŒä¹…åŒ–
  async saveTodos(sessionId: string, todos: any[]): Promise<void> {
    await this.workspaceService.writeFile(
      sessionId,
      'meta/todos.json',
      JSON.stringify(todos, null, 2),
      'utf-8'
    );
  }
  
  async loadTodos(sessionId: string): Promise<any[]> {
    try {
      const content = await this.workspaceService.readFile(
        sessionId,
        'meta/todos.json',
        'utf-8'
      );
      return JSON.parse(content as string);
    } catch {
      return [];
    }
  }
}
```

#### ç¤ºä¾‹ 2ï¼šé›†æˆ Checkpoint åˆ° AgentFactory

```typescript
// backend/agent/AgentFactory.ts ä¿®æ”¹éƒ¨åˆ†

import { PersistenceService } from '../services/persistence-service.js';
import { getWorkspaceFilesystem } from '../services/fs.js';

export class AgentFactory {
  private persistenceService: PersistenceService;
  
  constructor(configPath?: string) {
    // ... ç°æœ‰åˆå§‹åŒ–ä»£ç 
    
    // åˆå§‹åŒ–æŒä¹…åŒ–æœåŠ¡
    const workspaceService = getWorkspaceFilesystem();
    this.persistenceService = new PersistenceService(workspaceService);
  }
  
  async createAgent(sessionId: string, threadId?: string): Promise<any> {
    const actualThreadId = threadId || `thread-${Date.now()}`;
    
    // è·å– checkpointer
    const checkpointer = this.persistenceService.getCheckpointer(
      sessionId,
      actualThreadId
    );
    
    // åŠ è½½æœ€æ–°çŠ¶æ€ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    const lastCheckpoint = await checkpointer.load();
    
    // åˆ›å»º Agentï¼ˆä¼ å…¥æ¢å¤çŠ¶æ€ï¼‰
    const agent = await createDeepAgent({
      llm: await this.createLLM(),
      tools: await this.createTools(sessionId),
      middleware: await this.createMiddleware(sessionId),
      
      // çŠ¶æ€æ¢å¤
      initialState: lastCheckpoint ? {
        messages: lastCheckpoint.messages,
        todos: lastCheckpoint.todos,
        context: lastCheckpoint.context,
      } : undefined,
      
      // Checkpoint å›è°ƒ
      onStateUpdate: async (state: any) => {
        await checkpointer.save({
          messages: state.messages,
          todos: state.todos,
          context: state.context || {},
          executionStep: state.executionStep || 0,
          metadata: {
            totalTokens: state.totalTokens || 0,
            model: this.appConfig.agent.model,
            recursionDepth: state.recursionDepth || 0,
          },
        });
      },
    });
    
    return agent;
  }
  
  async closeAgent(sessionId: string, threadId: string): Promise<void> {
    await this.persistenceService.closeCheckpointer(sessionId, threadId);
  }
}
```

### 5.2 é…ç½®æ–‡ä»¶ç¤ºä¾‹

#### HITL é…ç½®æ–‡ä»¶

```typescript
// backend/config/hitl-config.ts

export interface HITLRule {
  action: string;
  enabled: boolean;
  autoApprove?: {
    enabled: boolean;
    conditions?: HITLCondition[];
  };
  timeout: number;
  requireReason?: boolean;
  priority?: 'high' | 'medium' | 'low';
}

export interface HITLCondition {
  type: 'whitelist' | 'blacklist' | 'filesize' | 'extension' | 'command' | 'regex';
  value: any;
}

export const DEFAULT_HITL_CONFIG: Record<string, HITLRule> = {
  // æ–‡ç”Ÿå›¾ - é«˜ä¼˜å…ˆçº§ï¼Œéœ€è¦ç¡®è®¤
  t2i: {
    action: 't2i',
    enabled: true,
    timeout: 30000,
    priority: 'high',
  },
  
  // è¯­éŸ³åˆæˆ - é«˜ä¼˜å…ˆçº§ï¼Œéœ€è¦ç¡®è®¤
  tts: {
    action: 'tts',
    enabled: true,
    timeout: 30000,
    priority: 'high',
  },
  
  // æ–‡ä»¶å†™å…¥ - ä¸­ä¼˜å…ˆçº§ï¼Œéƒ¨åˆ†è‡ªåŠ¨æ‰¹å‡†
  write_file: {
    action: 'write_file',
    enabled: true,
    autoApprove: {
      enabled: true,
      conditions: [
        // å®‰å…¨çš„æ–‡ä»¶æ‰©å±•å
        { 
          type: 'extension', 
          value: ['.txt', '.json', '.md', '.log', '.csv'] 
        },
        // æ–‡ä»¶å¤§å°é™åˆ¶
        { 
          type: 'filesize', 
          value: { max: 5 * 1024 * 1024 } // 5MB
        },
      ]
    },
    timeout: 60000,
    priority: 'medium',
  },
  
  // æ–‡ä»¶åˆ é™¤ - é«˜ä¼˜å…ˆçº§ï¼Œå¿…é¡»ç¡®è®¤å¹¶è¯´æ˜ç†ç”±
  rm: {
    action: 'rm',
    enabled: true,
    timeout: 60000,
    requireReason: true,
    priority: 'high',
  },
  
  // Shell æ‰§è¡Œ - é«˜ä¼˜å…ˆçº§ï¼Œç™½åå•å‘½ä»¤è‡ªåŠ¨æ‰¹å‡†
  execute: {
    action: 'execute',
    enabled: true,
    autoApprove: {
      enabled: true,
      conditions: [
        { 
          type: 'whitelist', 
          value: ['ls', 'pwd', 'echo', 'cat', 'head', 'tail', 'wc'] 
        },
      ]
    },
    timeout: 60000,
    priority: 'high',
  },
  
  // ç½‘ç»œè¯·æ±‚ - ä¸­ä¼˜å…ˆçº§ï¼Œç™½åå•åŸŸåè‡ªåŠ¨æ‰¹å‡†
  fetch: {
    action: 'fetch',
    enabled: true,
    autoApprove: {
      enabled: true,
      conditions: [
        {
          type: 'whitelist',
          value: [
            'api.openai.com',
            'api.anthropic.com',
            'generativelanguage.googleapis.com',
          ]
        },
      ]
    },
    timeout: 30000,
    priority: 'medium',
  },
};

// åŠ è½½ç”¨æˆ·è‡ªå®šä¹‰é…ç½®
export async function loadHITLConfig(): Promise<Record<string, HITLRule>> {
  try {
    const userConfigPath = path.join(process.cwd(), 'config', 'hitl-custom.json');
    const userConfig = JSON.parse(await fs.readFile(userConfigPath, 'utf-8'));
    
    // åˆå¹¶é»˜è®¤é…ç½®å’Œç”¨æˆ·é…ç½®
    return {
      ...DEFAULT_HITL_CONFIG,
      ...userConfig,
    };
  } catch {
    return DEFAULT_HITL_CONFIG;
  }
}
```

### 5.3 æµ‹è¯•ç­–ç•¥

#### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```typescript
// backend/tests/persistence-service.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { FileBasedCheckpointer, PersistenceService } from '../services/persistence-service';
import { getWorkspaceFilesystem } from '../services/fs';
import { randomUUID } from 'crypto';

describe('FileBasedCheckpointer', () => {
  let checkpointer: FileBasedCheckpointer;
  let sessionId: string;
  let threadId: string;
  let workspaceService: any;
  
  beforeEach(async () => {
    sessionId = `test-session-${randomUUID()}`;
    threadId = `test-thread-${randomUUID()}`;
    workspaceService = getWorkspaceFilesystem({ outputPath: './test-outputs' });
    checkpointer = new FileBasedCheckpointer(workspaceService, sessionId, threadId);
  });
  
  afterEach(async () => {
    // æ¸…ç†æµ‹è¯•æ•°æ®
    await workspaceService.rm(sessionId, '.');
  });
  
  it('should save and load checkpoint', async () => {
    const state = {
      messages: [{ role: 'user', content: 'hello' }],
      todos: [{ id: 1, title: 'test' }],
      context: { key: 'value' },
      executionStep: 1,
      metadata: {
        totalTokens: 100,
        model: 'gpt-4',
        recursionDepth: 0,
      },
    };
    
    const checkpointId = await checkpointer.save(state);
    expect(checkpointId).toBeDefined();
    
    const loaded = await checkpointer.load(checkpointId);
    expect(loaded).toBeDefined();
    expect(loaded!.messages).toEqual(state.messages);
    expect(loaded!.todos).toEqual(state.todos);
    expect(loaded!.context).toEqual(state.context);
  });
  
  it('should list all checkpoints', async () => {
    await checkpointer.save({ messages: [], todos: [], executionStep: 1 });
    await checkpointer.save({ messages: [], todos: [], executionStep: 2 });
    
    const list = await checkpointer.list();
    expect(list.length).toBe(2);
    expect(list[0].executionStep).toBe(1);
    expect(list[1].executionStep).toBe(2);
  });
  
  it('should load latest checkpoint by default', async () => {
    await checkpointer.save({ messages: [], todos: [], executionStep: 1 });
    await checkpointer.save({ messages: [], todos: [], executionStep: 2 });
    
    const latest = await checkpointer.load();
    expect(latest).toBeDefined();
    expect(latest!.executionStep).toBe(2);
  });
  
  it('should cleanup old checkpoints', async () => {
    const ids: string[] = [];
    for (let i = 0; i < 5; i++) {
      const id = await checkpointer.save({ 
        messages: [], 
        todos: [], 
        executionStep: i 
      });
      ids.push(id);
    }
    
    // ä¿ç•™æœ€æ–° 2 ä¸ª
    await checkpointer.cleanup({ keepLatest: 2 });
    
    const list = await checkpointer.list();
    expect(list.length).toBe(2);
    expect(list[0].executionStep).toBe(3);
    expect(list[1].executionStep).toBe(4);
  });
});
```

#### é›†æˆæµ‹è¯•ç¤ºä¾‹

```typescript
// backend/tests/hitl-integration.test.ts

import { describe, it, expect, beforeEach } from 'vitest';
import { HITLService } from '../services/hitl-service';
import { PersistenceService } from '../services/persistence-service';
import { DEFAULT_HITL_CONFIG } from '../config/hitl-config';

describe('HITL Integration Tests', () => {
  let hitlService: HITLService;
  
  beforeEach(() => {
    const persistenceService = new PersistenceService(/* ... */);
    hitlService = new HITLService(DEFAULT_HITL_CONFIG, persistenceService);
  });
  
  it('should auto-approve whitelisted shell commands', async () => {
    const result = await hitlService.requestApproval({
      action: 'execute',
      payload: { command: 'ls', args: ['-la'] },
      sessionId: 'test-session',
      threadId: 'test-thread',
    });
    
    expect(result.approved).toBe(true);
    expect(result.reason).toBe('auto-approved');
  });
  
  it('should require approval for non-whitelisted commands', async () => {
    // Mock UI response
    // ... (éœ€è¦æ¨¡æ‹Ÿ IPC é€šä¿¡)
  });
  
  it('should respect file size limits', async () => {
    const result = await hitlService.requestApproval({
      action: 'write_file',
      payload: { 
        filename: 'test.txt', 
        size: 1024,  // 1KB
        extension: '.txt' 
      },
      sessionId: 'test-session',
      threadId: 'test-thread',
    });
    
    expect(result.approved).toBe(true);
  });
});
```

---

## å…­ã€æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 6.1 Checkpoint æ€§èƒ½ä¼˜åŒ–

1. **å¢é‡ä¿å­˜**ï¼š
   - ä»…ä¿å­˜å˜æ›´çš„å­—æ®µï¼ˆdiffï¼‰
   - ä½¿ç”¨æŒ‡é’ˆå¼•ç”¨ä¸å˜çš„å¤§å¯¹è±¡

2. **å¼‚æ­¥å†™å…¥**ï¼š
   - ä½¿ç”¨é˜Ÿåˆ—ç¼“å†²å†™å…¥è¯·æ±‚
   - æ‰¹é‡å†™å…¥å¤šä¸ªå°æ–‡ä»¶

3. **å‹ç¼©å­˜å‚¨**ï¼š
   - å¯¹å¤§äº 10KB çš„ checkpoint è‡ªåŠ¨å‹ç¼©ï¼ˆgzipï¼‰
   - æ—§ checkpoint å¼‚æ­¥å‹ç¼©

4. **æ™ºèƒ½æ¸…ç†**ï¼š
   ```typescript
   // è‡ªåŠ¨æ¸…ç†ç­–ç•¥
   const CLEANUP_POLICY = {
     keepLatest: 10,           // ä¿ç•™æœ€æ–° 10 ä¸ª
     keepEveryNth: 50,         // æ¯ 50 ä¸ªä¿ç•™ 1 ä¸ªï¼ˆé‡Œç¨‹ç¢‘ï¼‰
     maxAge: 7 * 24 * 3600000, // 7å¤©
   };
   ```

### 9.2 æ–‡ä»¶ç³»ç»Ÿ I/O ä¼˜åŒ–

1. **è¯»ç¼“å­˜**ï¼š
   - ç¼“å­˜é¢‘ç¹è¯»å–çš„å…ƒæ•°æ®æ–‡ä»¶
   - LRU ç¼“å­˜ç­–ç•¥

2. **å†™ç¼“å†²**ï¼š
   - å°æ–‡ä»¶åˆå¹¶å†™å…¥
   - å»¶è¿Ÿå†™å…¥ï¼ˆdebounceï¼‰

3. **å¹¶å‘æ§åˆ¶**ï¼š
   - é™åˆ¶å¹¶å‘ I/O æ•°é‡
   - ä½¿ç”¨ p-queue ç®¡ç†

### 9.3 ç›‘æ§æŒ‡æ ‡

```typescript
// backend/services/metrics-service.ts

export interface SystemMetrics {
  persistence: {
    checkpointCount: number;
    totalCheckpointSize: number;
    avgSaveTime: number;
    avgLoadTime: number;
  };
  
  h 8.1tl: {
    totalRequests: number;
    approvedCount: number;
    rejectedCount: number;
    timeoutCount: number;
    autoApprovedCount: number;
    avgResponseTime: number;
  };
  
  workspace: {
    sessionCount: number;
    totalFileCount: number;
    totalStorageSize: number;
    quotaViolations: number;
  };
}

export class MetricsService {
  async collect(): Promise<SystemMetrics>;
  async export(format: 'json' | 'prometheus'): Promise<string>;
}
```

---

## åã€æ€»ç»“ä¸åç»­è§„åˆ’

### 10.1 æ ¸å¿ƒæ”¹è¿›

æœ¬é‡æ„æ–¹æ¡ˆå‚è€ƒ OpenWork æ¶æ„ï¼Œå¯¹ DeepAgentUI è¿›è¡Œäº†å…¨é¢å‡çº§ï¼š

1. âœ… **æŒä¹…åŒ–å±‚**ï¼šå®ç°åŸºäºæ–‡ä»¶çš„ Checkpoint æœºåˆ¶ï¼Œæ”¯æŒ Agent çŠ¶æ€æ¢å¤
2. âœ… **Session ç®¡ç†**ï¼šå¢å¼ºç”Ÿå‘½å‘¨æœŸç®¡ç†ã€èµ„æºç»Ÿè®¡ã€è‡ªåŠ¨æ¸…ç†
3. âœ… **Workspace ç®¡ç†**ï¼šæ·»åŠ èµ„æºé…é¢ã€æƒé™æ§åˆ¶ã€æ“ä½œç›‘æ§
4. âœ… **HITL æœºåˆ¶**ï¼šæ‰©å±•è¦†ç›–èŒƒå›´ã€å®ç°è‡ªåŠ¨æ‰¹å‡†ã€æ”¯æŒè‡ªå®šä¹‰è§„åˆ™
5. âœ… **å®¡è®¡æ—¥å¿—**ï¼šå®Œæ•´çš„æ“ä½œè¿½è¸ªå’Œå®¡è®¡èƒ½åŠ›

### 10.2 æ¶æ„ä¼˜åŠ¿

- **å®‰å…¨æ€§**ï¼šå¤šå±‚ HITL ä¿æŠ¤ï¼Œæ“ä½œå¯å®¡è®¡
- **å¯é æ€§**ï¼šçŠ¶æ€å¯æŒä¹…åŒ–ã€å¯æ¢å¤
- **å¯æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºæ‰©å±•æ–°åŠŸèƒ½
- **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„èŒè´£åˆ’åˆ†ï¼Œå®Œå–„çš„æµ‹è¯•è¦†ç›–

### 10.3 åç»­è§„åˆ’

**çŸ­æœŸï¼ˆ1-3ä¸ªæœˆï¼‰**ï¼š
- [ ] å®Œæˆæ‰€æœ‰é˜¶æ®µå®æ–½
- [ ] æ€§èƒ½ä¼˜åŒ–ä¸å‹æµ‹
- [ ] æ–‡æ¡£å®Œå–„ä¸åŸ¹è®­

**ä¸­æœŸï¼ˆ3-6ä¸ªæœˆï¼‰**ï¼š
- [ ] åˆ†å¸ƒå¼ Checkpoint æ”¯æŒï¼ˆå¤šæœºåŒæ­¥ï¼‰
- [ ] Web ç‰ˆæœ¬æ”¯æŒï¼ˆæµè§ˆå™¨ IndexedDBï¼‰
- [ ] é«˜çº§å®¡è®¡åˆ†æï¼ˆå›¾è¡¨ã€æŠ¥è¡¨ï¼‰

**é•¿æœŸï¼ˆ6-12ä¸ªæœˆï¼‰**ï¼š
- [ ] å¤šç§Ÿæˆ·æ”¯æŒ
- [ ] ä¼ä¸šçº§æƒé™ç®¡ç†ï¼ˆRBACï¼‰
- [ ] äº‘ç«¯å¤‡ä»½ä¸åŒæ­¥

---

## é™„å½•

### A. ç›®å½•ç»“æ„å˜æ›´

```
backend/
  services/
    fs.ts                      # ç°æœ‰ â†’ é‡æ„ä¸ºåŒ…å« WorkspaceService
    persistence-service.ts     # æ–°å¢
    session-service.ts         # æ–°å¢
    hitl-service.ts           # æ–°å¢
    audit-service.ts          # æ–°å¢
    log-manager.ts            # æ–°å¢
    runtime-manager.ts        # æ–°å¢
  
  config/
    hitl-config.ts            # æ–°å¢
    workspace-config.ts       # æ–°å¢
    log-config.ts             # æ–°å¢
    feature-flags.ts          # æ–°å¢
  
  tests/
    persistence-service.test.ts
    hitl-service.test.ts
    session-service.test.ts
    audit-service.test.ts
    runtime-manager.test.ts
    integration.test.ts

outputs/
  workspaces/
    {sessionId}/
      meta/
        session.json          # å¢å¼º
        messages.json         # ç°æœ‰
        todos.json            # ç°æœ‰
      checkpoints/            # æ–°å¢ï¼ˆç®€åŒ–ï¼Œæ—  threadIdï¼‰
        index.json
        state_xxx.json
        state_latest.json
      images/
      audio/

logs/                         # æ–°å¢ï¼šç»Ÿä¸€æ—¥å¿—ç›®å½•
  llm/
    {date}/
      {sessionId}_llm.log
  audit/
    {date}/
      {sessionId}_audit.jsonl
  hitl/
    {date}/
      {sessionId}_hitl.jsonl
  system/
    app.log
    error.log
```

### B. API å˜æ›´æ¸…å•

#### æ–°å¢ IPC æ¥å£

```typescript
// electron/ipc/hitl.ts
'hitl:request'           // å‘é€ HITL è¯·æ±‚åˆ° UI
'hitl:response:${id}'    // UI å“åº” HITL è¯·æ±‚

// electron/ipc/session.ts
'session:archive'        // å½’æ¡£ session
'session:cleanup'        // æ¸…ç†è¿‡æœŸ session
'session:stats'          // è·å– session ç»Ÿè®¡

// electron/ipc/audit.ts
'audit:query'            // æŸ¥è¯¢å®¡è®¡æ—¥å¿—
'audit:export'           // å¯¼å‡ºå®¡è®¡æ—¥å¿—
```

---

## ä¹9
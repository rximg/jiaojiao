# DDD核心概念及桌面端后端迁移指南

# 一、DDD核心框架整体性讲述

领域驱动设计（Domain-Driven Design，DDD）是一种以业务领域为核心，将业务逻辑与技术实现分离，通过统一领域模型解决复杂业务问题的软件设计方法论。其核心框架本质是“围绕领域建模，分层解耦，聚焦业务价值”，打破传统“数据驱动”的设计模式，让软件设计贴合业务实际，提升系统的可扩展性、可维护性和业务可读性。

DDD核心框架的核心逻辑分为“战略设计”和“战术设计”两大层面，二者相辅相成：战略设计聚焦“宏观层面”，解决业务边界划分、领域拆分、团队协作等问题，确保系统设计与业务目标对齐；战术设计聚焦“微观层面”，提供具体的建模工具和实现方法，将战略设计的成果落地为可执行的代码结构，完成领域模型的具象化。

整体框架以“领域模型”为核心枢纽，连接战略层的边界划分和战术层的代码实现，辅以分层架构（领域层、应用层、接口层、基础设施层）隔离关注点，让业务逻辑集中在领域层，技术细节封装在基础设施层，最终实现“业务与技术解耦，模型与代码统一”的目标。

# 二、DDD核心概念全面简洁描述（补充实操细节）

## （一）战略设计相关概念（聚焦业务边界与全局规划）

- **领域（Domain）**：业务活动的范围和边界，是DDD的核心载体，对应一个具体的业务领域（如桌面端软件的“用户管理领域”“数据同步领域”“权限控制领域”）。核心是“业务范围+业务规则”，包含该领域内所有高频业务场景、核心业务流程及不可突破的业务约束（如桌面端“数据同步领域”，包含同步触发、断点续传、冲突解决等业务流程，及“同步数据不可篡改”的业务规则）。

- **子领域（Subdomain）**：将一个大领域按业务职责拆分的小型领域，每个子领域聚焦一个具体的业务方向，避免领域过大导致建模混乱。具体分为三类：核心子领域（业务核心，决定系统价值，如桌面端“离线数据同步领域”）、支撑子领域（为核心子领域提供支撑，非核心但必要，如“同步日志领域”）、通用子领域（可复用，跨多个子领域，如日志记录、缓存管理、异常处理，可直接复用或轻微适配）。

- **限界上下文（Bounded Context）**：定义领域模型的边界，是一个“语义和规则一致”的范围，核心作用是解决“同一术语不同含义”的问题。在该范围内，领域模型的概念、术语、业务规则完全统一（如“用户”在“用户管理上下文”中侧重账号密码、个人信息，在“权限管理上下文”中侧重角色、权限分配，二者语义隔离，避免模型冲突）；不同限界上下文之间的模型相互独立，仅通过上下文映射交互。

- **上下文映射（Context Mapping）**：描述不同限界上下文之间的关系和交互方式，核心是解决跨上下文的模型协作，避免直接耦合。针对桌面端后端常见映射关系：防腐层（ACL，最常用），用于隔离外部上下文（如第三方接口、原有旧系统），避免外部模型污染本上下文；客户-供应商关系，如“权限管理上下文”（供应商）为“用户管理上下文”（客户）提供权限校验能力。

- **领域愿景（Domain Vision）**：明确领域的核心价值和业务目标，是DDD设计的“指南针”。无需复杂描述，核心是“一句话说清领域价值”（如桌面端“数据同步领域”的愿景：实现桌面端与服务端数据实时、安全、高效同步，保障离线使用体验），确保所有设计动作都围绕该愿景展开，不偏离业务核心。

## （二）战术设计相关概念（聚焦模型落地与业务封装）

- **实体（Entity）**：具有唯一标识（ID），且生命周期内状态可变化的领域对象，核心是“身份标识”而非属性。实操关键：ID必须全局唯一（如桌面端“用户”实体，用用户ID作为唯一标识，而非姓名/手机号）；状态变化需符合业务规则（如用户密码修改，需校验旧密码，修改后记录更新时间，状态变化可追溯）；示例：桌面端“任务”实体（任务ID唯一，状态可从“待执行”变为“执行中”“已完成”）。

- **值对象（Value Object）**：无唯一标识，仅由属性值决定，状态不可变，用于描述实体的特征，可复用。实操关键：属性相同即视为同一个对象（如“用户地址”值对象，包含省、市、区、详细地址，只要这四个属性相同，无论属于哪个用户，都视为同一个地址对象）；状态不可变（如创建后不可修改，修改需重新创建新的地址对象）；示例：桌面端“时间范围”“文件大小”“接口请求参数规范”。

- **聚合（Aggregate）**：由一组关联的实体和值对象组成的“整体单元”，核心是“维护对象一致性”，避免跨对象操作导致的业务冲突。实操关键：聚合内对象紧密关联、不可拆分（如“用户聚合”包含用户实体、用户权限实体、用户配置值对象）；对外仅暴露聚合根一个入口，外部不可直接操作聚合内非根对象（如修改用户权限，必须通过用户聚合根调用相关方法，而非直接操作权限实体）。

- **聚合根（Aggregate Root）**：聚合的核心实体，具有唯一全局标识，是聚合的“对外代言人”。实操关键：负责聚合内对象的创建、修改和一致性校验（如创建用户时，同步创建默认权限和配置，校验用户信息合法性）；是领域模型与外部交互的唯一节点（如桌面端后端查询用户权限，需通过用户聚合根查询，而非直接查询权限表）；示例：“用户”“任务”均可作为聚合根。

- **领域服务（Domain Service）**：封装不属于任何实体或值对象的业务逻辑，用于处理跨实体、跨聚合的业务操作，无状态、可复用。实操关键：仅协调业务流程，不存储数据（如“用户注册校验服务”，需协调用户实体（校验账号唯一性）、权限实体（分配初始权限）、日志领域服务（记录注册日志），自身不存储任何状态）；命名需贴合业务（如“数据同步校验服务”“任务分配服务”）。

- **领域事件（Domain Event）**：领域内发生的具有业务意义的事件，用于记录领域状态的变化，实现领域内组件解耦，避免硬编码依赖。实操关键：包含事件标识、发生时间、事件数据（如“用户注册成功事件”，包含用户ID、注册时间、初始角色）；采用发布/订阅模式，事件发布者无需关注订阅者，订阅者按需处理（如注册成功事件发布后，权限服务订阅并分配权限，日志服务订阅并记录日志）。

- **工厂（Factory）**：封装复杂领域对象（尤其是聚合）的创建逻辑，隐藏创建细节，确保创建的对象符合领域规则。实操关键：用于创建复杂聚合（如“任务聚合”，包含任务实体、任务关联的文件信息值对象、任务执行人实体，创建逻辑复杂，适合用工厂封装）；避免创建逻辑散落在业务代码中，降低维护成本（如桌面端“任务聚合工厂”，统一处理任务创建的校验、关联对象初始化逻辑）。

- **仓储（Repository）**：定义领域对象的持久化接口，隔离领域层与基础设施层的持久化细节，实现“领域层不依赖数据库”。实操关键：接口定义在领域层，实现类放在基础设施层（如领域层定义“用户仓储”接口，包含查询、保存、删除方法；基础设施层实现该接口，处理MySQL查询、Redis缓存等细节）；仅操作聚合根，不直接操作聚合内非根对象（如保存用户聚合，通过用户仓储保存聚合根，聚合内的权限、配置对象由聚合根统一管理持久化）。

## （三）分层架构相关概念（聚焦分层解耦与职责划分）

- **领域层（Domain Layer）**：DDD的核心层，纯业务层，与具体技术实现无关，是系统的“业务心脏”。核心职责：封装所有业务规则和业务逻辑，包含领域模型（实体、值对象、聚合等）、领域服务、领域事件、工厂、仓储接口；实操关键：不引入任何技术框架依赖（如不引入Spring、MyBatis相关类），仅关注业务本身。

- **应用层（Application Layer）**：协调层，“无业务逻辑，仅做协调”，是领域层与接口层的桥梁。核心职责：接收接口层的请求，协调领域层的组件（实体、领域服务、仓储等），串联业务流程，完成用户用例的执行；示例：桌面端“用户注册接口”的应用层实现，仅调用用户仓储查询账号唯一性、调用领域服务校验信息、调用工厂创建用户聚合、调用仓储保存，不包含任何业务规则判断。

- **接口层（Interface Layer）**：对外交互层，负责与桌面端客户端（或其他外部系统）对接，屏蔽内部架构细节。核心职责：接收外部请求（如桌面端的HTTP请求、RPC请求），将请求参数转换为应用层能处理的格式（如DTO转换），调用应用层用例接口，将处理结果转换为外部可识别的格式返回；实操关键：仅负责请求/响应转换、接口暴露，不处理任何业务逻辑和数据持久化。

- **基础设施层（Infrastructure Layer）**：支撑层，为其他层提供技术支撑，封装所有技术细节。核心职责：实现领域层定义的仓储接口（处理数据库交互、缓存等）；提供通用技术工具（如日志工具、加密工具、异常处理工具）；封装外部依赖（如第三方接口、消息队列）；实现领域事件的发布/订阅机制；实操关键：隔离技术细节对领域层的影响，当技术框架替换（如MySQL换PostgreSQL）时，仅修改基础设施层实现，不影响领域层和应用层。

## （一）战略设计相关概念

- **领域（Domain）**：业务活动的范围和边界，是DDD的核心载体，对应一个具体的业务领域（如桌面端软件的“用户管理领域”“数据同步领域”“权限控制领域”），包含该领域内的所有业务规则和业务流程。

- **子领域（Subdomain）**：将一个大领域按业务职责拆分的小型领域，每个子领域聚焦一个具体的业务方向，分为核心子领域（业务核心，决定系统价值）、支撑子领域（为核心子领域提供支撑，非核心但必要）、通用子领域（可复用，跨多个子领域，如日志、缓存）。

- **限界上下文（Bounded Context）**：定义领域模型的边界，是一个“语义和规则一致”的范围，在该范围内，领域模型的概念、术语、业务规则是统一的，不同限界上下文之间的模型相互独立，通过上下文映射进行交互，解决模型混乱和语义冲突。

- **上下文映射（Context Mapping）**：描述不同限界上下文之间的关系和交互方式，核心作用是解决跨上下文的模型协作，常见映射关系有合作关系、共享内核、客户-供应商关系、防腐层（ACL）等。

- **领域愿景（Domain Vision）**：明确领域的核心价值和业务目标，指导整个DDD设计过程，确保所有设计动作都围绕业务价值展开，避免偏离业务核心。

## （二）战术设计相关概念

- **实体（Entity）**：具有唯一标识（ID），且生命周期内状态可变化的领域对象，核心是“身份标识”而非属性（如桌面端的“用户”，ID唯一，姓名、密码等属性可变化）。

- **值对象（Value Object）**：无唯一标识，仅由属性值决定，状态不可变，用于描述实体的特征（如“用户地址”“时间范围”，属性相同即视为同一个对象，无需区分身份）。

- **聚合（Aggregate）**：由一组关联的实体和值对象组成的“整体单元”，用于维护领域对象的一致性，指定一个“聚合根”（Aggregate Root）作为对外交互的唯一入口，聚合内的对象只能通过聚合根访问，外部不可直接操作聚合内非根对象。

- **聚合根（Aggregate Root）**：聚合的核心实体，具有唯一全局标识，负责聚合内对象的创建、修改和一致性校验，是领域模型与外部交互的核心节点（如“用户”作为聚合根，关联“用户权限”“用户配置”等对象，外部仅能通过用户操作这些关联对象）。

- **领域服务（Domain Service）**：封装不属于任何实体或值对象的业务逻辑，用于处理跨实体、跨聚合的业务操作，无状态，仅负责业务流程的协调（如“用户注册校验服务”，需协调用户实体、权限实体的相关逻辑）。

- **领域事件（Domain Event）**：领域内发生的具有业务意义的事件，用于记录领域状态的变化，实现领域内组件的解耦（如“用户注册成功事件”，可触发权限分配、日志记录等后续操作）。

- **工厂（Factory）**：封装复杂领域对象（尤其是聚合）的创建逻辑，隐藏对象创建的细节，确保创建的对象符合领域规则，避免在业务代码中散落创建逻辑（如“用户聚合工厂”，负责创建用户及关联的权限、配置对象）。

- **仓储（Repository）**：定义领域对象的持久化接口，隔离领域层与基础设施层的持久化细节，领域层通过仓储接口操作数据，无需关注数据存储的具体实现（如“用户仓储”，定义用户的查询、保存、删除接口，由基础设施层实现数据库交互）。

## （三）分层架构相关概念

- **领域层（Domain Layer）**：DDD的核心层，包含领域模型（实体、值对象、聚合等）、领域服务、领域事件等，封装所有业务规则和业务逻辑，与具体技术实现无关。

- **应用层（Application Layer）**：协调层，不包含业务逻辑，仅负责协调领域层的组件，完成用户用例的执行（如“用户注册接口”，调用领域服务、仓储等组件，串联整个注册流程），对外提供统一的用例入口。

- **接口层（Interface Layer）**：对外交互层，负责接收外部请求（如桌面端客户端的请求），将请求转换为应用层能处理的格式，再将应用层的处理结果返回给外部，包含接口定义、请求/响应转换等（如REST接口、RPC接口）。

- **基础设施层（Infrastructure Layer）**：支撑层，为其他层提供技术支撑，实现仓储接口（数据库交互）、提供工具类、封装外部依赖（如缓存、消息队列）、实现领域事件的发布/订阅等，隔离技术细节对领域层的影响。

# 三、桌面端软件后端DDD架构迁移步骤（简述）

桌面端软件后端通常以“数据驱动”为主（如三层架构：表现层、业务逻辑层、数据访问层），迁移DDD架构的核心是“从数据驱动转向领域驱动”，聚焦业务边界划分和领域建模，逐步完成分层重构，步骤如下：

## 1. 业务调研与领域划分（战略设计阶段）

梳理桌面端软件的核心业务场景（如用户登录、数据同步、任务管理、权限控制等），拆分业务领域和子领域，明确核心子领域（如桌面端的“数据同步领域”）和支撑子领域，划分各子领域的限界上下文，确定上下文映射关系，梳理领域愿景和核心业务规则，为后续建模奠定基础。

## 2. 领域建模（战术设计阶段）

基于限界上下文，在每个上下文内进行领域建模：识别领域内的实体、值对象，划分聚合和聚合根，梳理实体与实体、实体与值对象的关联关系；提炼领域服务，封装跨实体的业务逻辑；定义领域事件，记录业务状态变化；设计工厂和仓储接口，规范对象创建和数据持久化的方式，确保模型贴合业务实际。

## 3. 分层架构重构（落地实现阶段）

按照DDD分层架构，重构原有后端代码结构：

- 提取原有业务逻辑层中的核心业务规则，封装到领域层（实体、领域服务等）；

- 将原有业务逻辑层的流程协调代码，迁移到应用层，封装为用例接口；

- 保留并优化原有接口层，适配应用层的用例接口，确保与桌面端客户端的交互兼容；

- 重构数据访问层，实现领域层定义的仓储接口，封装数据库交互、缓存等技术细节，形成基础设施层。

## 4. 代码迁移与适配

逐步迁移原有后端代码：优先迁移核心子领域的代码，将原有数据模型转换为DDD的实体、值对象，将原有业务逻辑重构为领域服务或实体方法；适配原有接口，确保迁移过程中桌面端客户端的正常访问（可采用“增量迁移”，避免一次性重构导致系统不可用）；处理跨上下文的交互，通过上下文映射（如防腐层）解决不同限界上下文的模型冲突。

## 5. 测试与优化

针对迁移后的架构进行全面测试：验证领域模型的正确性（业务规则是否符合预期）、应用层用例的完整性（流程是否顺畅）、接口层的兼容性（与桌面端交互是否正常）、数据持久化的准确性（仓储实现是否可靠）；优化领域模型和代码结构，解决迁移过程中出现的耦合、性能问题，确保系统的可维护性和可扩展性。

## 6. 落地与迭代

完成全量代码迁移和测试后，正式上线DDD架构的后端系统；后续结合桌面端软件的业务迭代，持续优化领域模型，调整限界上下文和分层结构，逐步完善DDD架构的落地效果，确保系统始终贴合业务发展需求。
> （注：文档部分内容可能由 AI 生成）